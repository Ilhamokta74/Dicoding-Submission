# -*- coding: utf-8 -*-
"""Sub_2_Model_ML_Dengan_DTS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mY_ZIFB7e27UTjCwwDs7-GZY4bTzhoDF

*   Nama : Ilham Oktavian
*   Dataset : train-ML-Sub2.csv
*   Sumber : Kaggle
*   Link Dataset : https://www.kaggle.com/datasets/robikscube/hourly-energy-consumption/data
"""

from google.colab import drive
drive.mount('/content/drive')

# Library
import numpy as np
import pandas as pd
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

# Tentukan jalur file CSV
file_path = './drive/MyDrive/Dataset/train_ML_Sub2.csv'

# Baca file CSV ke dalam DataFrame
df = pd.read_csv(file_path)

# Tampilkan lima baris pertama dari DataFrame
df.head()

# Menampilkan jumlah baris dalam DataFrame
num_rows = len(df)
num_rows

# Menampilkan informasi ringkas tentang DataFrame
df_info = df.info()
df_info

# Menghitung jumlah nilai null dalam setiap kolom DataFrame
null_counts = df.isnull().sum()
null_counts

# Mengambil nilai dari kolom 'Datetime' dan 'EKPC_MW' dalam bentuk array
dates = df['Datetime'].values
EKPC_NW = df['EKPC_MW'].values

# Mengatur ukuran gambar plot
plt.figure(figsize=(15, 5))

# Membuat plot time series menggunakan data 'dates' dan 'EKPC_NW'
plt.plot(dates, EKPC_NW)

# Menambahkan judul plot
plt.title('Timeseries Of Total Energy Used by EKPC', fontsize=20)

# Menambahkan label sumbu x dan y
plt.xlabel('Datetime')
plt.ylabel('Energy')

# Menampilkan plot
plt.show()

# Mengonversi kolom 'Datetime' ke tipe data datetime
df['Datetime'] = pd.to_datetime(df['Datetime'])

# Menampilkan informasi ringkas tentang DataFrame setelah perubahan
df_info_after_conversion = df.info()
df_info_after_conversion

# Mengubah bentuk array 'EKPC_NW' menjadi matriks satu kolom
EKPC_NW = EKPC_NW.reshape(-1, 1)

# Menampilkan array setelah perubahan bentuk
EKPC_NW

# Inisialisasi objek MinMaxScaler
scaler = MinMaxScaler()

# Menggunakan MinMaxScaler untuk melakukan penskalaan Min-Max pada 'EKPC_NW'
EKPC_NW_scaled = scaler.fit_transform(EKPC_NW)

# Menampilkan hasil penskalaan
EKPC_NW_scaled

X_train, X_test, y_train, y_test = train_test_split(EKPC_NW, dates, test_size=0.2, shuffle=False)

def windowed_dataset(series, window_size, batch_size, shuffle_buffer):
    # Menambahkan dimensi tambahan pada series (asumsi series adalah satu dimensi)
    series = tf.expand_dims(series, axis=-1)

    # Membuat dataset dari tensor series
    ds = tf.data.Dataset.from_tensor_slices(series)

    # Membuat jendela geser pada dataset
    ds = ds.window(window_size + 1, shift=1, drop_remainder=True)

    # Membuat batch dari jendela geser
    ds = ds.flat_map(lambda w: w.batch(window_size + 1))

    # Mengacak urutan data dalam dataset
    ds = ds.shuffle(shuffle_buffer)

    # Memisahkan setiap jendela menjadi fitur dan label
    ds = ds.map(lambda w: (w[:-1], w[-1:]))

    # Membagi dataset menjadi batch dengan ukuran tertentu dan melakukan prefetching
    return ds.batch(batch_size).prefetch(1)

# Membuat dataset pelatihan dan pengujian menggunakan fungsi windowed_dataset
train_set = windowed_dataset(X_train, window_size=60, batch_size=100, shuffle_buffer=1000)
test_set  = windowed_dataset(X_test, window_size=60, batch_size=32, shuffle_buffer=1000)

# Membuat model sequential dengan layer LSTM dan Dense
model = tf.keras.models.Sequential([
    tf.keras.layers.LSTM(60, return_sequences=True, input_shape=[None, 1]),
    tf.keras.layers.LSTM(60),
    tf.keras.layers.Dense(30, activation="relu"),
    tf.keras.layers.Dense(10, activation="relu"),
    tf.keras.layers.Dense(1)
])

# Menghitung rentang data EKPC_NW
data_range = EKPC_NW.max() - EKPC_NW.min()

# Menghitung batas maksimal nilai MAE (10%) dari rentang data
threshold_mae = data_range * 10 / 100

# Menampilkan hasil
print("Batas maksimal nilai MAE (10%) dari data adalah sebesar", threshold_mae)

class myCallback(tf.keras.callbacks.Callback):
    def on_epoch_end(self, epoch, logs={}):
        # Mendapatkan nilai MAE dan val_mae dari logs
        current_mae = logs.get('mae')
        current_val_mae = logs.get('val_mae')

        # Mengecek apakah keduanya berada di bawah threshold
        if current_mae is not None and current_val_mae is not None:
            if current_mae < threshold_mae and current_val_mae < threshold_mae:
                print("MAE < 10%, pelatihan dihentikan.")
                self.model.stop_training = True

# Membuat objek callback
callbacks = myCallback()

# Menggunakan Stochastic Gradient Descent (SGD) sebagai optimizer dengan learning rate dan momentum tertentu
optimizer = tf.keras.optimizers.SGD(learning_rate=1.0000e-04, momentum=0.9)

# Mengompilasi model dengan Huber loss, SGD optimizer, dan mae sebagai metrik
model.compile(loss=tf.keras.losses.Huber(),
              optimizer=optimizer,
              metrics=["mae"])

# Melatih model dengan data pelatihan dan evaluasi pada data validasi
# Callback callbacks=myCallback() digunakan untuk menghentikan pelatihan jika MAE < 10%
hist = model.fit(train_set,
                 epochs=50,
                 validation_data=test_set,
                 verbose=2,
                 callbacks=[callbacks])

# Plot MAE (Mean Absolute Error) pada set pelatihan dan set validasi

# Menampilkan nilai MAE pada set pelatihan
plt.plot(hist.history['mae'], label='Train MAE')

# Menampilkan nilai MAE pada set validasi
plt.plot(hist.history['val_mae'], label='Validation MAE')

# Menambahkan judul dan label pada sumbu
plt.title('MAE Model')
plt.ylabel('MAE')
plt.xlabel('Epoch')

# Menambahkan legenda untuk membedakan antara set pelatihan dan set validasi
plt.legend(loc='upper right')

# Menampilkan plot
plt.show()

# Plot Loss pada set pelatihan dan set validasi

# Menampilkan nilai loss pada set pelatihan
plt.plot(hist.history['loss'], label='Train Loss')

# Menampilkan nilai loss pada set validasi
plt.plot(hist.history['val_loss'], label='Validation Loss')

# Menambahkan judul dan label pada sumbu
plt.title('Loss Model')
plt.ylabel('Loss')
plt.xlabel('Epoch')

# Menambahkan legenda untuk membedakan antara set pelatihan dan set validasi
plt.legend(loc='upper right')

# Menampilkan plot
plt.show()